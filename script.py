"""Игра ведется двумя игроками. Побеждает тот, кто первым заполнит крестикам или ноликами строку, или столбец, или диагональ на
игровом поле. Размер поля запрашивается в начале игры. Можно играть на полях размером от 3х3 до 9х9. Когда на поле создается ситуация, при которой
ни один из игроков не выиграл и не сможет выйграть, тогда заканчивается, ввиду ея дальнейшей бессмысленности."""

def startPF(N): #Определяем функцию, которая создает начальное игровое поле = список списков
    PF = [] #список - игровое поле
    PF.append([' ']) #добовляем первый список на игровое поле, состоящей из одного элемента - пробела
    PF[0].extend([str(i) for i in range(1, N + 1)]) #добавляем в первый список = верхнюю строку игрового поля номера столбцов и ...
    PF[0].extend(['0','0']) #в конец два поля для хранения количества "крестиков" и "ноликов" на побочной диагонали.
    for i in range(1, N + 1): #с первой строки до строки N ...
        PF.append([str(i)]) #добавляем сами строки, ...
        PF[i].extend(['*' for j in range(1, N + 1)]) #во вновь созданные строки добавляем в столбцы с 1 по N символы '*', ...
        PF[i].extend(['0', '0']) #а в конец строк еще по два поля с нулями, в которых будет записываться количество "крестиков" и "ноликов" в строке.
    PF.append([]) #Добавляем в список-игровое поле еще один список-строку N+1. В этой строке будет записываться количество "крестиков" в столбце,
    # а в двух последних полях - количество "крестиков" и "ноликов" на "главной" диагонали.
    PF[N + 1].extend(['0' for j in range(N + 3)]) #всю строку заполняем нулями.
    PF.append([]) #Добавляем к игровому полю строку N+2, в которой будет записываться количество "крестиков" и "ноликов" столбцах.
    PF[N + 2].extend(['0' for j in range(N + 3)]) #Заполняем строку N+2 нулями. Первое и два последних поля в строке не будут использованы никак. Они никому не нужны!
    return PF #Функция возвращает список = готовое игровое поле.

def printPF(PF, N): #Определяем функцию, печатающую на консоль только ту часть игрового поля, которую надо. На вход функция получает список, который надо напечатать
    #и размер стороны игрового поля, хотя и могла бы его вычислить.
    print('Текущее положение на игровом поле:') #Печатаем заголовок
    for j in range(N + 1): #Со строки 0 до строки N ...
        str = ' '.join(PF[j]) # вставляем пробелы между символами, для красоты
        print(str[0:(2*N + 1)]) #печатаем строку от начала до последнего символа, который надо показывать.
#    for j in range(N + 3):
#        str = ' '.join(PF[j])
#        print(str)



def cellUP(a): #Определяем функцию, которая увеличивает на 1 значение числа, которое она получает в виде строки.
    a = int(a) #Преобразуем принятую строку в целое число
    return str(a + 1) #увеличиваем число на 1 и полученное значение возвращаем преобразованным в строку.

def PFCheck(PF,N): #Определяем функцию, которая проверяет положение на игровом поле и что-то возвращает по результату проверки.
    #На вход функция получает игровое поле и длину его стороны.
    listX = [] #Список для количеств "крестиков" в строках и столбцах
    listO = [] #Список для количеств "ноликов" в строках и столбцах
    for i in range(N + 2): #для строк с 0 до N+2 включительно ...
        listX.extend(PF[i][N + 1]) #добавляем в служебный список значения полей, содержащих количество "крестиков", ...
        listO.extend(PF[i][N + 2]) #добавляем в служебный список значения полей, содержащих количество "ноликов".
    for i in range(1, N + 1): #Для стольбцов от 1 до N включительно ...
        listX.extend(PF[N + 1][i]) #в служебный список добавляем количества "крестиков" в столбцах, ...
        listO.extend(PF[N + 2][i]) #в служебный список добавляем количества "ноликов" в столбцах.
    if any(i == str(N) for i in listX) or any (i == str(N) for i in listO): #Если есть диагональ, стольбец или строка целиком заполненная "крестиками" или "ноликами", ...
        return 'V' #то функция возвращает строку 'V'
    elif all(i != '0' for i in listX) and all(i != '0' for i in listO): #Если на всех диагоналях, в столбцах и строках
        #есть "крестики" и "нолики", ...
        return 'D' #то функция возвращает строку 'D'
    else: #Если два пердыдущих условия не выполнились, ...
        return 'C' #то функция возвращает строку 'C'


def crosshair_and_nonentity(): #Основная функция. Ее надо вызывать для запуска программы.
    N = input('Введите высоту или ширину игрового поля (по умолчанию - 3): ') #N - это натуральное число от 3 до 9 включительно - размер игрового поля NxN
    if not (N.isdigit() and 3<= int(N) <= 9): #Проверяем, является ли N - цифрой. Если нет - то N = 3
        N = 3
    else:
        N = int(N) #Если N -цифра, то делаем из цифры целое число, типа int.
    playingField = startPF(N) #Игровое поле созданное функцией startPF(N). Размер поля NxN.
    Player = [] #Список игроков
    PlCh = ['X', 'O'] #Список символов, которвые используют игроки. Первый игрок - всегда 'X', второй - всегда 'O'
    Player.append(input('Введите имя первого игрока: ')) #Добавляем в список игроков имя первого игрока, ввдеденное с клавиатуры
    Player.append(input('Введите имя второго игрока: ')) #Добавляем в список игроков имя второго игрока, ввдеденное с клавиатуры
    PlCur = 0 #Переменная хранит число, которое обозначает текущего активного игрока. 0 - первый, 1 - второй
    printPF(playingField, N) #Выводим на консоль игровое поле в его стартовом состоянии.
    while True: #Основной цикл, в нем производится заполнение игрового поля до победы оного из игроков или до ничьей - ситуации, когда никто не сможет победить и продолжение игры не имеет смысла.
        InRC = list(input('Игрок ' + Player[PlCur] + ', введите номер строки и номер столбца: ').replace(' ','')) #Два числа от 1 до N,
        # введенные подряд, как двузначное число или через любое количество пробелов. Первое число - номер строки Y, от 1 до N, сверху вниз. Второе число -
        # номер столбца X, от 1 до N слева направо. На пересечении строки Y и столбца X, будет поставлен символ текущего игрока O или X.
        if all(i == '0' for i in InRC): # если текущй грок ввел два нуля, то ...
            print('Игра прервана игроком ' + Player[PlCur]) #сообщаем об этом на консоль и ...
            break #выходим из цикла, что равно прекращению работы программы, в данном случае.
        elif len(InRC) < 2: #Если игрок ввел меньше двух символов ...
            print('Не скупитесь, введите два числа!') #сообщаем ему об этом, ...
            continue #и отправляем повторить ввод.
        elif len(InRC) > 2: #Если игрок ввле больше двух символов
            print('Слишком много чисел! Нужно ровно два!') #сообщаем ему об этом, ...
            continue #и отправляем повторить ввод.
        elif not all(i.isdigit() for i in InRC): #Если пользователь ввел не цифры ...
            print('Повнимательние, пожалуйста! Надо использовать только числа!')  #сообщаем ему об этом, ...
            continue #и отправляем повторить ввод.
        elif not all(0 < i < N + 1 for i in list(map(int, InRC))): #Если пользователь ввлел координаты выходящие за границы поля ...
            print('В этой игре номера строк и колонок могут принимать значения от 1 до ' + str(N))   #сообщаем ему об этом, ...
            continue #и отправляем повторить ввод.

        y, x = list(map(int, InRC)) #Перобразуем введенные пользователем цифры в числа и записываем из хначения в переменные x и y.
        if playingField[y][x] == '*': #Если в ячейке с координатами (y,x) записан символ '*' ...
            playingField[y][x] = PlCh[PlCur] #заменяем его на символ текущего игрока, и ...
            playingField[y][N + 1 + PlCur] = cellUP(playingField[y][N + 1 + PlCur]) #увеличиваем на 1 цифру в поле, которое хранит количество текущих символов в строке
            playingField[N + 1 + PlCur][x] = cellUP(playingField[N + 1 + PlCur][x]) #увеличиваем на 1 цифру в поле, которое хранит количество текущих символов в столбце
            if x == y: #Если номер строки равен номеру столбца, то эта ячейка лежит на "главной" диоганали поля.
                playingField[N + 1][N + 1 + PlCur] = cellUP(playingField[N + 1][N + 1 + PlCur]) #увеличиваем на 1 цифру в поле, которое хранит количество текущих символов в главной диагонале.
            if x + y == N + 1: #Если выпольняется равенство, то ячейка лежит на "побочной" диаголе.
                playingField[0][N + 1 + PlCur] = cellUP(playingField[0][N + 1 + PlCur]) #увеличиваем на 1 цифру в поле, которое хранит количество текущих символов в "побочной" диагонале.
            printPF(playingField, N) #Выводим на консоль игровое поле с введеным символом.
            if PFCheck(playingField, N) == 'V': #Проверяем значение функции проверяющей состояние игры. Если функция вернула 'V', то ...
                print('Игрок ' + Player[PlCur] + ' победил!!!') #Сообщаем, что текущий игрок победил, и ...
                break #заканчиваем работу программы.
            elif PFCheck(playingField, N) == 'D': #Если функция проверки игры вернула 'D', то ...
                print('"Рыба"!!!') #сообщаем в консоль, о завершении игры вничью, и ...
                break #завершаем работу программы.
            elif PFCheck(playingField, N) == 'C': #Если функция проверки игры вернула 'C', то ...
                PlCur = (PlCur + 1) % 2 #меняем текущего игрока и игра продолжается.
        else: #Если игрок ввел координаты ячейки в которой стоит символ отличный от '*'
            print('Ячейка ' + str(y) + ' ' + str(x) + ' уже занята. Выберете свободную ячейку') #предлагаем ему повторить ввод, и ...
            continue #переходим на следующий круг.



tic_tac_toe()
